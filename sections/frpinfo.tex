
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%						INTRO IS MASTER http://www.edwardamsden.com/static/publications/thesis.pdf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Random intro}

Pagrindinė funkcinio programavimo abstrakcija yra funkcija, kuri priima tam tikrą įvestį, o jos rezultatas yra tam tikrą išvestis. Funkcijos įvestis bei rezultatas gali būti kita funkcija. Funkcinėje programavimo kalboje funkcijos yra pirmos eilės reikšmės.

Priešingai, labiau populiarus imperatyvaus programavimo modelis priima sakinius arba veiksmus kaip pirminius programos konstravimo blokus, kurie modifikuoja būseną. Tokios programos turi nuoseklų kontrolės srautą ir reikalauja samprotavimo apie pašalinius efektus. Iš prigimties jie yra atsparūs kompoziciniam samprotavimui.

Netgi funkcinėse programavimo kalbose, reaktyvios programos yra paprastai parašytos imperatyviu stiliumi, naudojant žemo lygio bei ne paruoštų komponentų abstrakcijas įskaitant atgalinius skambintojus arba objektu paremtais įvykių dorokliais. Tai pririša modelį prie interaktyvumo prie žemo lygio realizacijos detalių tokių kaip laikas bei įvykių apdorojimo modeliai.

Funkcinis reaktyvus programavimas reiškia, jog modelis turi išlaikyti funkcinio protamavimo charakteristikas (pavyzdžiui, primityvios kalbos konstrukcijos turi likti pirmosios klasės) įtraukiant reaktyvumą į kalbos modelį. Ypač funkcijos turėtų būti panaikintos, jog operuotų reaktyviomis reikšmėmis ir pačios funkcijos privalo būti reaktyvios.

Pagrindinis FRP tikslas yra suteikti kompozicines ir aukšto lygio abstrakcijas, jog būtų galima kurti reaktyvias programas. 
Pagrindinės FRP abstrakcijos yra:

\begin{itemize}

	\item elgesys - laike kintančios reikšmės apibrėžtos kiekviename besitęsiančio laiko taške;

	\item įvykiai - reikšmės apibrėžtos suskaičiuojamose laiko taškuose.

\end{itemize}

Funkcinio reaktyvaus programavimo sistema suteiks kombinatorius manipuliuoti įvykiais bei elgesiu ir reaguoti į įvykius pakeičiant dalį veikiančios programos kaip atsaką į įvykį. Elgesys bei įvykiai arba tam tikra jų abstrakcija bus pirmos klasės. Funkcinia reaktyvia programavimo kalba realizuotos programos turi būti efektyviai įvykdomos, bet tai yra įrodyta kaip sunkiausias funkcinio reaktyvaus programavimo uždavinys.

Du bendri požiūriai į FRP yra:

\begin{itemize}

	\item klasikinis FRP - elgesys ir įvykiai yra pirmos klasės ir reaktyvūs objektai;

	\item signalo-funkcijos FRP - elgesio ir įvykių transformatoriai yra pirmos eilės ir reaktyvūs objektai.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%						KLASIKINIS FRP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Klasikinis FRP}

Anksčiausia ir dar vis standartinė FRP formuluotė pateikia du primityvius tipų konstruktorius - Behavior (elgesys) ir Event (įvykis) - kartu su kombinatoriais, kurie pagamina šių tipų reikšmes. Lengviausias semantinis apibrėžimas šiems tipams yra pateiktas \ref{classic_semantic}.

\begin{lstlisting}[caption=- klasikinio FRP semantiniai tipai, label=classic_semantic]
	type Event a = [(Time, a)]
	type Behavior a = Time -> a
\end{lstlisting} 

Kai šie du tipų konstruktoriai yra tiesiogiai išreikšti, sistema yra žinoma kaip klasikinė FRP sistema.

\subsubsection{Klasikinio FRP istorija}

Klasikinis FRP buvo originaliai parašytas kaip Fran[8] (Funkcininė reaktyvi animacija). Fran yra karkasas, skirtas deklaratyviai specifikuojant interaktyvias animacijas. Fran atvaizduoja elgesį kaip dvi pavyzdines funkcijas, vieną nuo laiko iki reikšmės ir kitą nuo laiko intervalo (apatinė ir viršutinė laiko riba) iki reikšmės intervalo ir naujo elgesio. Įvykiai atvaizduojami kaip "tobulėjančios reikšmės", kurios imant su laiku pagamina žemesnią laiko ribą kitam atvejui, arba kitą įvykį jeigu jis iš tikrųjų įvyko.

Pirmoji FRP realizacija ne Haskell kalboje buvo Frappe [4], realizuota naudojantis Java Beans karkasu. Frappe yra sukurta remiantis įvykių supratimu bei Beans karkaso susietomis sąvybėmis (bound properties) teikiant abstrakčias sąsajas FRP įvykiams ir elgesiui bei kombinatorius kaip konkrečias klases, realizuojančias šias sąsajas. 

\subsubsection{Dabartinės klasikinės FRP sistemos}

FrTime[1] kalba išplečia Scheme skaičiuoklį nepastoviu priklausomybių grafu, kuris yra sukonstruojamas įvertinus programą. Signalų pasikeitimai atnaujina šį grafą. FrTime nesuteikia atskirų įvykių sąvokų ir pasirenka priklausomybių grafo šakas naudojant sąlyginį elgesio įvertinimą, o ne elgesio pakeitimą, naudojamą FRP sistemų.

Reactive [7] sistema yra dvitaktė (angl. push-pull) funkcinio reaktyvaus programavimo sistema su pirmos klasės elgesiu bei įvykiais. Pirminė Reactive įžvalga yra reaktyvumo (arba kitaip atsako pasikeitimai į įvykius, kurių atsitikimo laikas negalėjo būti žinomas prieš tai) ir laiko priklausomybės atskyrimas. Tai duoda kelią reaktyviąjai normalinėj formai, kuri atvaizduoja elgesį kaip konstantą arba paprastai priklausančią nuo laiko reikšmę, kartu su įvykių srauto nešamomis reikšmėmis, kurios irgi yra reaktyvios normalinės formos elgesys. Stūmimu (angl. push) paremtas įverinimas yra pasiekiamas šakojant Haskell gijas, jog būtų įvertintas galvos elgesys kol yra laukiama įvykių srauto įvertinimo. Įvykus įvykiui, dabartinio elgesio gija yra nužudoma ir sukuriama nauja gija įvertinti naują elgesį. Deja Reactive realizacija naudoja nepatvarią techniką, kuri priklauso nuo gijų šakojimosi įvertinant dvi Haskell reikšmes lygiagrečiai, kad būtų galima realizuoti įvykių sujungimą. Tai priklauso nuo bibliotekos autoriaus, kad būtų galima užtikrinti darną kai naudojama ši technika ir priveda prie gijų nuotėkio kai vienas iš sujungtų įvykių yra įvykių sujungimo rezultatas.

Nauja tezė [6] aprašo Elm - autonominią kalbą reaktyvumui. Elm suteikia kombinatorius manipuliuoti diskrečiais įvykiais ir kompiliuojasi į Javascript kalbą, kas padaro tai naudinga kliento pusės web programavimui. Tačiau Elm nesuteikia perjungimo arba besitęsiančio laiko elgesio, nors suderinimas yra pateikiamas naudojant diskretaus laiko įvykius, kurie yra sužadinami pasikartojančiais intervalais, specifikuotais apibrėžiant įvykį. Tezė teigia, jog Arrowized FRP (signalų-funkcijų FRP) gali būti integruota į Elm, bet suteikia pažai paramos šiam teiginiui. \footnote{A form of Arrowized FRP employing applicative functors is presented, and justified by
the assertion that applicative functors are just arrows with the input type parameter fixed.
}

Reactive-banana [0] biblioteka yra dvitaktė (angl. push-pull) FRP sistema sukurta naudoti su Haskell GUI karkasu. Visų pirma, ji charakterizuoja monadą elgesio ir įvykių kūrimui, kuri gali būti komponuojama bei įvertinama. Ši monada apima konstrukcijas GUI bibliotekos konstrukcijų pririšimui prie primityvių įvykių. Ji privalo būti įkomponuojama į Haskell IO veiksmą įvertinimui įvykti. Reactive-banana realizacija yra panaši į FrTime - naudojant priklausomybių grafą tinklo atnaujinimui įvykus įvykiui. Reactive-banana taip pat kaip Frtime vengia apibendrinto perjungimo vietoje elgesio reikšmių šakojimosi funkcijų, bet išlaiko elgesio ir įvykių atskyrimo. Užuot apibendrinto perjungimo kombinatoriaus, kuris leidžia pakeisti sutartinį elgesį, reactive-banana suteikia žingsninį kombinatorių, kuris pažingsniui sukuria elgesį iš įvykio srauto reikšmių.

\subsubsection{Signalo funkcijos FRP}

Alternatyvus FRP būdas pirmą kartą pasiūlytas darbe apie Fruit[5]. Fruit yra biblioteka, skirta deklaratyviam GUI specifikavimui. Biblioteka naudoja rodyklės[9] sąvoką signalo-funkcijos abstrakcijai. Rodyklės yra abstraktaus tipo konstruktoriai su įvesties ir išvesties tipo parametrais kartu su rinkiniu maršruto parinkimo kombinatorių. Tai demonstruojama \ref{arrow_combinators}. Rodyklės idėja Haskell kalboje, įskaitant rodyklių kombinatorių aksiomas, kurias turi tenkinti, yra išvesti iš rodyklių sąvokų iš kategorijų teorijos.

\begin{lstlisting}[caption=- rodyklių kombinatoriai, label=arrow_combinators]
	(>>>) :: (Arrow a) => a b c -> a c d -> a b d
	arr :: (Arrow a) => (b -> c) -> a b c
	first :: (Arrow a) => a b c -> a (b, d) (c, d)
	second :: (Arrow a) => a b c -> a (d, b) (d, c)
	(***) :: (Arrow a) => a b c -> a b d -> a b (c, d)
	loop :: (Arrow a) => a (b, d) (c, d) => a b c
\end{lstlisting} 

Signalų funkcijos yra nuo laiko priklausančios ir įvykių bei elgesio reaktyvūs transformatoriai. Elgesys ir įvykiai negali būti tiesiogiai manipuliuojami. Šis būdas turi du motyvus: padidina modalumą, kadangi signalo funkcijų įvestis ir išvestis gali būti transformuojama ir tai išvengia didelės laiko klasės ir atminties nuotėkio, kas nutinka kai FRP realizuojamas kaip pirmos klasės elgesys ir įvykiai.

Panašiai kaip ir FrTime, Netwire [17] biblioteka vengia dinaminio perjungimo, šiuo atveju dėl signalo slopinimo. Netwire yra parašyta kaip rodyklės tranformatorius. Signalo slopinimas yra įgyvendintas padarant signalo funkcijų išvestį monoidu ir tada sujungiant signalo funkcijų išvestis. Prislopinta signalo funkcija pagamina monoido nulį (monoid's zero) kaip išvestį. Primityvai apibrėžia elgesio slopinimą ir sukomponuotos signalo funkcijos slopina jeigu jų išvestis dera su monoido nuliu.

Yampa[11] yra rodyklyzuotos FRP sistemos optimizacija, pirmą kartą panaudota Fruit. Yampa realizacija naudoja Generalized Algebraic Datatypes, kad leistų daug didesnę saugaus tipo duomenų tipų klasę signalo funkcijos reprezentaijai. Šis atvaizdavimas kartu su "išmaniais" konstruktoriais ir kombinatoriais suteikia galimybė konstruoti rodyklizuotą FRP sistemą, kuri optimizuoja pati save. Deja pagrindinis neefektyvumas yra nereikalingi įvertinimo žingsniai dėl traukimu paremto (angl. pull-based) įvertinimo. Optimizacija yra speciali ir kieviena nauja optimizacija reikalauja naujų konstruktorių pridėjimo, taip pat kiekvieno primityvaus kombinatoriaus atnaujinimo kiekvienai konstruktorio kombinacijai palaikyti. Tačiau Yampa parodo aiškų efektyvumo privalumą lyginant su prieš tai aprašytomis rodyklizuotomis FRP realizacijomis.

PhD tezė [16] pristatė N-Ary FRP - techniką tipizuojant rodyklizuotas FRP sistemas naudojant priklausomus tipus. Didžioji dalis darbo sudarė priklausomų tipų sistemos korektiškumo įrodymas. Šis darbas pristatė signalų vektorius, tipizuotą konstruktorių, kuris leidžia elgesio bei įvykių atskyrimą FRP sistemos lygyje vietoje įvykių laikymo tik specialiu elgesio tipu.

\subsubsection{Neįvykdyti iššūkiai}

Yra dvi pagrindinės FRP problemos. Pirma, kol signalo-funkcijos FRP yra iš prigimties saugesnė ir labiau modulinė negu klasikinė FRP, ji dar turi būti efektyviai realizuota. Klasikinės FRP programos yra pažeidžiamos dėl laiko nuotėkio bei priežastingumo pažeidimų dėl galimybės tiesiogiai manipuliuoti reaktyviomis reikšmėmis. Antra, sąsaja tarp FRP programų ir daugybės atskirų įvesties ir išvesties šaltinių išlieka specialūs ir daugeliu atveju realizacijos limituotu variantu.

Viena pagrindinė išimtis yra Reactive-banana sistema, kuri suteikia monadą primityvių įvykių konstravimui ir elgesiui iš kuriuos FRP programa gali būti sukonstruota. Tačiau šis būdas yra nelankstus, nes jis reikalauja bibliotekos palaikymo sistemai. Negana to, būnant klasikine FRP sistema, Reactive-banana pritrūksta galimybės transformuoti elgesio bei įvykių įvestį, kadangi visa įvestis yra neišreikštinė.





\subsubsection{Naudota čia}

[0] Heinrich Apfelmus. reactive-banana library. http://hackage.haskell.org/package/reactive-banana.

[1] http://cs.brown.edu/people/sk/Publications/Papers/Published/ick-adapt-oo-fwk-frp/paper.pdf

[4] Antony Courtney. Frapp ́e: Functional reactive programming in Java. In
Proceedings of the Third International Symposium on Practical Aspects of Declarative Languages, PADL ’01, pages 29–44, London, UK, UK, 2001. Springer-Verlag.

[5] Antony Courtney and Conal Elliott. Genuinely functional user interfaces. In Proceedings of the 2001 Haskell Workshop, pages 41–69, 2001.

[6] Evan Czaplicki. Elm: Concurrent FRP for functional GUIs. http:// www.testblogpleaseignore.com/wp-content/uploads/2012/03/thesis. pdf, 2012.


[7] Conal Elliott. Push-pull functional reactive programming. In Haskell Symposium, 2009.]

[8] Conal Elliott and Paul Hudak. Functional reactive animation. In Pro- ceedings of the second ACM SIGPLAN international conference on Func- tional programming, ICFP ’97, pages 263–273, New York, NY, USA, 1997. ACM.

[9] John Hughes. Generalising monads to arrows. Science of Computer Programming, 37(13):67 – 111, 2000

[11] Henrik Nilsson. Dynamic optimization for functional reactive program- ming using generalized algebraic data types. In Proceedings of the tenth ACM SIGPLAN international conference on Functional programming, ICFP ’05, pages 54–65, New York, NY, USA, 2005. ACM.

[16] Neil Schulthorpe. Towards Safe and Efficient Functional Reactive Pro- gramming. PhD thesis, University of Nottingham, UK, 2011.


[17]ErtugrulS ̈oylemez. netwirelibrary. http://hackage.haskell.org/ package/netwire-3.1.0.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%						INTRO IS MASTER http://haskell.cs.yale.edu/wp-content/uploads/2011/02/icfp97.pdf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Fran Abstract}

Fran (Functional Reactive Animation) yra kolekcija duomenų tipų ir funkcijų, skirtų komponuoti labai interaktyvias multimedijos animacijas. Pagrindidės Fran idėjos yra elgesio ir įvykio sąvokos. Elgesys yra laike kintančios reaktyvios reikšmės, o įvykiai yra rinkinys sudėtingų būsenų galimai nešančių gausų informacijos kiekį. Dauguma tradicinių reikšmių gali būti laikomos elgesiu. Kai vaizdai yra apdorojami - jie tampa animacijomis. Nors šios didėjos yra laikomos kaip duomenų tipai, o ne programavimo kalba, jiems galima suteikti semantiką įskaitant teisingą apdorojimą realiu laiku, jog būtų galima apgalvoti realizaciją. Metodas efektyviai aptikti įvykius  naudojantis intervalų analizę yra taipogi apibūdintas. Jis remiasi daline įvykių laikų domeno srities informacijos struktūra. Fran buvo realizuotas Hugs suteikdamas stebėtinai gerą našumą interpretatoriumi paremtose sistemose. Keli pavyzdžiai yra duoti, įskaitant galimybę apibūdinti fizinius reiškinius įskaitant gravitaciją, svyruokles, greitį, pagreitį ir t.t. naudojantis paprastas diferencialines lygtis.

\subsubsection{Įvadas Fran}

Interactyvios multimedijos animacijų kūrimas (įskaitant audio, nuotraukas, video, 2D ir 3D grafiką) ilgai buvo sudėtingas ir nuobodus procesas. Tikima, jog sunkumas kyla dėl pakankamai aukšto lygio abstrakcijų nebuvimo, ir ypač dėl sunkumo atskirti modeliavimo ir prezentacijos lygmenis arba kitais žodžiais, tarp to kas yra animacija ir kaip ji turėtų būti atvaizduota. Dėl šios priežasties, programos turi išreikštinai valdyti bendrus realizacijos detales, kurios neturi nieko bendro su animacijos turiniu, o ne patį atvaizdavimą naudojantis žemo lygio vaizduoklio bibliotekas. Šios realizacijos detalės apima:

\begin{itemize}

	\item modeliavimą ir kadrų generavimą pažingsniui keliaujant laiku nepaisant to, jog animaciją yra iš esmės tolydi;

	\item judesio įvesties įvykių sekų surinkimą ir apdorojimą nepaisant to, jog judesio įvestis iš esmės yra tolydi;

	\item laiko dalijimą atnaujinant kiekvieną laike besikeičiančią animacijos parametrą nepaisant to, jog šie parametrai iš esmės lygiagrečiai skiriasi.

\end{itemize} 

Leidžiant programuotojams išreikšti "kas" yra interaktyvi informacija, kažkas gali tikėtis automatizuoti "kaip" tai atvaizduojama. Šiuo požiūriu, neturėtų būti netikėta, jog rinkinys išraiškingų rekursyvių duomenų tipų sujungtų su deklaratyvia programavimo kalba leidžia patogiai modeliuoti animacijas, priešingai nei bendrinė praktika naudoti imperatyvias kalbas sutartinai mišriam modeliavimo/prezentacijos stiliui. Taipogi yra rasta ne griežta semantika, aukštesnės eilės funkcijos, stiprus polimorfinis tipizavimas ir sistemingas perkrovimas yra vertingos kalpos sąvybės, leidžiančios palaikyti sumodeliuotą animaciją. Dėl šių priežasčių, Fran suteikia duomenų tipus programavimo kalboje Haskell.

\subsubsection{Modeliavimo privalumai lyginant su prezentacija}

Modeliavimo privalumai prieš animaciją yra panašūs į funkcinės (arba galima sakyti deklaratyvios) programavimo kalbos paradigmą ir apima aiškumą, kūrimo lengvumą, komponavimą ir švarią semantiką. Be šių yra programai būdingų privalumų, tam tikrais atvejais patrauklesnių iš programinės įrangos kūrėjos bei galutinio vartotojo perspektyvos. Šie privaluai apima:

\begin{itemize}

	\item Kūrimas - turinio kūrimo sistemos natūraliai konstruoja modelius, nes šių sistemų galutinis vartotojas mąsto modelio terminais ir paprasta neturi nei noro nei patirties programavimo prezentacijos detalėse.

	\item Optimizuojamumas - modeliu paremtos sistemos turi prezentacijos subsistemą, kuri gali atvaizduoti bet kokį modelį, kuris gali būti sukurtas sistemoje. Egzistuoja daug galimybių optimizacijai, nes aukšto lygio informacijos detalės yra prieinamos prezentacijos subsistemai.

	\item Reguliavimas - prezentacijos subsistema gali lengviau apibrėžti detalių išsamumo lygio valdymą bei pavyzdžių ėmimo dažnį, būtiną interaktyvioms animacijoms, remiantis reginio sudėtingumo, mašinos greičiu ir apkrova ir t.t.

	\item Mobilumas ir saugumas - modeliavimo platformos nepriklausomumas palengvina mobilių aplikacijų, kurios yra įrodytai saugios WWW(World Wide Web) programos, konstravimą.

\end{itemize}

\subsubsection{Modeliavimo esmė}

Yra keturios pagrindinės modeliavimo idėjos:

\begin{itemize}

	\item Laikinas modeliavimas. Reikšmės, vadinamos elgesiu, kurios kinta bėgant laikui yra labiausiai dominančios. Elgesys yra pirmos klasės reikšmės ir sukurtos kompoziciškai. Lygiagretumas yra išreikštas natūraliai ir neišreikštinai. Pavyzdžiui, sekanti išraiška išreiškia animaciją (paveikslėlio elgesį), kas yra apskritimas ant kvadrato. Laiko taške t, apskritimas turi dydį sin t ir kvadratas turi dydį cos t.

\begin{lstlisting}
	bigger (sin time) circle 'over' bigger (cos time) square
\end{lstlisting}

	\item Įvykių modeliavimas. Kaip ir elgesys, įvykiai yra pirmos eilės reikšmės. Įvykiai gali reikšti tam tikrus nutikimus realiame pasaulyje (pavyzdžiui, pelės mygtuko paspaudimas) arba predikatus paremtus animacijos parametrais (pavyzdžiui, artimumą arba susidūrimą). Tokie įvykiai gali būti sujungti su kitais iki norimo sudėtingumo taip atskiriant sudėtingą animacijos logiką į semantiškai turiningus, modulius konstravimo blokus. Pavyzdžiui, įvykis, aprašantis pirmą kairio mygtuko paspaudimą po laiko t0 yra paprasčiausiai \textit{1bp t0}; aprašantis laiko kvadratą lygų penkiems yra \textit{predicate (pow(time, 2) == 5 t0)} ir jų loginė disjunkcija \textit{1bp t0 .|. predicate (pow(time, 2) == 5) t0}

	\item Deklaratyvus reaktyvumas. Elgesys dažnai yra natūraliai išreiškiamas kaip atsakas į įvykį. Bet netgi šis reaktyvus elgesys turi deklaratyvią semantiką dėl būsenos pasikeitimų, neretai įtraukiamų į įvykiais paremtą formalizmą. Pavyzdžiui, spalvos reikšmės elgesys, kuris periodiškai keičiasi iš raudonos į žalią su kiekvienu mygtuko paspaudimu gali būti aprašytas kaip paprastas pasikartojimas:

\begin{lstlisting}
	colorCycle t0 =
		red 'untilB' 1bp t0 *=> \\t1 ->
		green 'untilB' 1bp t0 *=> \\t1 ->
		colorCycle t2
\end{lstlisting}

	\item Polimorfinė medija. Laike besikeičiančių medijų (nuotraukos, video, garsas, 3D grafika) įvairovė ir šių tipų parametrai (erdvinės transformacijos, spalvos, taškai, vektoriai, skaičiai) turi savo pačių specialiai tipui opecijas (pavyzdžiui, nuotraukų sukimas, garso maišymas, skaitmeninė sudėtis), tačiau sutelpa į bendrinį elgesio ir reaktyvumo karkasą. Pavyzdžiui, 'untilB' operaciją naudojama prieš tai yra polimorfinė, tinkanti bet kuriai laike beisikeičiančiai reikšmei.

\end{itemize}